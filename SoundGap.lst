.cpu 6502

; On the web: [http://www.alienbill.com/2600/101/docs/stella.html Stella Programmer's Guide]

; The address decoding for the 2600 is very simple. The TIA is accessed
; if A12 is 0 and A7 is 0. The TIA is selected if (address&1080 == 0000).
;
; The TIA chip uses the 6 lower address lines A0-A5. The reads seem to 
; ignore A4 and A5.
;
; The addresses have different read/write definitions and many of them
; are strobes that are triggered by writing any value.
;
; Note that the 6502 has an 8-bit stack pointer. The CPU automatically sets the upper
; byte of the address to 01. The RIOT chip RAM ghosts from 00xx to 01xx putting the stack
; in RAM.

; TIA

; Reads
.CXM0P    = 0x0000 ; Collisions M0/P1
.CXM1P    = 0x0001 ; Collisions M1/P0
.CXP0FB   = 0x0002 ; Collisions M0/PF
.CXP1FB   = 0x0003 ; Collisions P1/PF
.CXM0FB   = 0x0004 ; Collisions M0/PF
.CXM1FB   = 0x0005 ; Collisions M1/PF
.CXBLPF   = 0x0006 ; Collisions BL/PF
.CXPPMM   = 0x0007 ; Collisions P0/P1
.INPT0    = 0x0008 ; Paddle input 0
.INPT1    = 0x0009 ; Paddle input 1
.INPT2    = 0x000A ; Paddle input 2
.INPT3    = 0x000B ; Paddle input 3
.INPT4    = 0x000C ; Latched inputs (joystick buttons)
.INPT5    = 0x000D ; Latched inputs (joystick buttons)

; Writes
.VSYNC    = 0x0000 ; D1=1 starts the vertical sync 
.VBLANK   = 0x0001 ; D1=1 starts the vertical blank (D6 and D7 config INPT0-5) 
.WSYNC    = 0x0002 ; Halts processor until leading edge of horizontal blank 
.RSYNC    = 0x0003 ; Resets sync counter (used in chip testing) 
.NUSIZ0   = 0x0004 ; Number and size of player/missile P0 
.NUSIZ1   = 0x0005 ; Number and size of player/missile P0 
.COLUP0   = 0x0006 ; Color-luminance of player 0 
.COLUP1   = 0x0007 ; Color-luminance of player 1 
.COLUPF   = 0x0008 ; Color-luminance of play filed 
.COLUBK   = 0x0009 ; Color-luminance of background 
.CTRLPF   = 0x000A ; Control playfield, priorities, and ball size 
.REFP0    = 0x000B ; D3=1 reflects player 0 
.PEFP1    = 0x000C ; D3=1 reflects player 1 
.PF0      = 0x000D ; Playfield 0 bits (upper 4 bits) 
.PF1      = 0x000E ; Playfield 1 bits 
.PF2      = 0x000F ; Playfield 2 bits 
.RESP0    = 0x0010 ; Set horizontal position of player 0 
.RESP1    = 0x0011 ; Set horizontal position of player 1 
.RESM0    = 0x0012 ; Set horizontal position of missile 0 
.RESM1    = 0x0013 ; Set horizontal position of missile 1 
.RESBL    = 0x0014 ; Set horizontal position of ball 
.AUDC0    = 0x0015 ; Noise, tone, division control channel 0 
.AUDC1    = 0x0016 ; Noise, tone, division control channel 1 
.AUDF0    = 0x0017 ; Frequency divider channel 0 
.AUDF1    = 0x0018 ; Frequency divider channel 1 
.AUDV0    = 0x0019 ; Volume channel 0 
.AUDV1    = 0x001A ; Volume channel 1 
.GRP0     = 0x001B ; Player 0 graphics 
.GRP1     = 0x001C ; Player 1 graphics 
.ENAM0    = 0x001D ; D1=1 to enable missile 0 
.ENAM1    = 0x001E ; D1=1 to enable missile 1 
.ENABL    = 0x001F ; D1=1 to enable ball 
.HMP0     = 0x0020 ; Horizontal motion offset for player 0 
.HMP1     = 0x0021 ; Horizontal motion offset for player 1 
.HMM0     = 0x0022 ; Horizontal motion offset for missile 0 
.HMM1     = 0x0023 ; Horizontal motion offset for missile 1 
.HMBL     = 0x0024 ; Horizontal motion offset for ball 
.VDELP0   = 0x0025 ; D0=1 to delay player 0 one vertical line 
.VDELP1   = 0x0026 ; D0=1 to delay player 1 one vertical line 
.VDELBL   = 0x0027 ; D0=1 to delay ball one vertical line 
.RESMP0   = 0x0028 ; D1=1 to reset missile 0 to player 0 
.RESMP1   = 0x0029 ; D1=1 to reset missile 1 to player 1 
.HMOVE    = 0x002A ;  Executes horizontal motions 
.HMCLR    = 0x002B ; Clears all horizonal motion registers 
.CXCLR    = 0x002C ; Clears all collision registers 

; PIA

; The PIA (R.I.O.T.) is accessed if A12 is 0 and A7 is 1. If A9 is 0 then the 128 bytes 
; of RAM are selected. If A9 is 1 then the PIA timer registers are selected.
;
; The TIA REGS are selected if (address&1280 == 0280).
;
; The TIA RAM is selected if (address&1280 == 0080).
;
; The PIA chip uses the lower 7 address lines A0-A6. Thus the 007F mask below.

.SWCHA    = 0x0280 ; Port A Hand controllers 
.SWACNT   = 0x0281 ; Port A DDR 

.SWCHB    = 0x0282 ; Port B Console switches 
; D7 : P1 difficulty (0=amateur, 1=pro)
; D6 : P0 difficulty (0=amateur, 1=pro)
; D5 : not used
; D4 : not used
; D3 : color or B/W (0=B/W, 1=color)
; D2 : not used
; D1 : game select (0=pressed)
; D0 : game reset (0=pressed)

.SWBCNT   = 0x0283 ; Port B DDR 
.INTIM    = 0x0284 ; Timer output (read only) 
.TIM1T    = 0x0294 ; Set 1 clock interval (write only) 
.TIM8T    = 0x0295 ; Set 8 clock interval (write only) 
.TIM64T   = 0x0296 ; Set 64 clock interval (write only) 
.TIM1024T = 0x0297 ; Set 1024 clock interval (write only) 

;  RAM usage

.tmp0             =     0x80 ; First RAM address
.tmp1             =     +    ; 0x81
.tmp2             =     +    ; 0x82
.tmp3             =     +
.playr0y          =     +
.mustmp1          =     +
.scancnt          =     +
.mode             =     +
.wall_inc         =     +
.wallcnt          =     +
.walldely         =     +
.walldelyr        =     +
.entropya         =     +
.debounce         =     +
.walldrela        =     +
.walldrelb        =     +
.walldrelc        =     +
.wallstart        =     +
.gapbits          =     +
; This buffer needs 6 bytes total
.score_pf1        =     +
.score_pf1b       =     +
.score_pf1c       =     +
.score_pf1d       =     +
.score_pf1e       =     +
.score_pf1f       =     +

; FC00 through FFFF is 1K

FC00:
MAIN:
FC00: 78                SEI                   ; Turn off interrupts
FC01: D8                CLD                   ; Clear the "decimal" flag

; http://atariage.com/forums/topic/27405-session-12-initialisation
; Nice, tight code to clear memory and registers at startup
FC02: A2 00             LDX   #0              ; 0 to ...
FC04: 9A                TXS                   ; ... SP
FC05: 8A                TXA                   ; 0 to A (for clearing memory)
FC06: 48                PHA                   ; SP is now FF (the end of memory)
Clear:
FC07: 48       Clear:   PHA                   ; Store 0
FC08: CA                DEX                   ; All 256 of memory+registers cleared?
FC09: D0 FC             BNE   Clear           ; No ... do all. SP ends at FF again

FC0B: 20 F2 FC          JSR  INIT             ; Initialize game environment
FC0E: 20 83 FD          JSR  INIT_SELMODE     ; Start out in SELECT mode (fall into main loop)

; Start here at the end of every screen frame
;
VIDEO_KERNEL:

FC11: A9 02          LDA   #2              ; Wait for ...
FC13: 85 02          STA   WSYNC           ; ... the end of the current line
FC15: 85 01          STA   VBLANK          ; Turn the beam off
FC17: 85 02          STA   WSYNC           ; Wait ...
FC19: 85 02          STA   WSYNC           ; ... three ...
FC1B: 85 02          STA   WSYNC           ; ... scanlines
FC1D: 85 00          STA   VSYNC           ; Trigger the vertical sync signal
FC1F: 85 02          STA   WSYNC           ; Hold the vsync signal for ...
FC21: 85 02          STA   WSYNC           ; ... three ...
FC23: 85 02          STA   WSYNC           ; ... scanlines
FC25: 85 2A          STA   HMOVE           ; Tell hardware to move all game objects
FC27: A9 00          LDA   #0              ; Release ...
FC29: 85 00          STA   VSYNC           ; ... the vertical sync signal
FC2B: A9 2B          LDA   #43             ; Set timer to 43*64 = 2752 machine ...
FC2D: 8D 96 02       STA   TIM64T          ; ... cycles 2752/(228/3) = 36 scanlines

         ;  ***** LENGTHY GAME LOGIC PROCESSING BEGINS HERE *****

         ;  Do one of 3 routines while the beam travels back to the top
         ;  0 = Game Over processing
         ;  1 = Playing-Game processing
         ;  2 = Selecting-Game processing

FC30: E6 8C             INC   entropya        ; Counting video frames as part of the random number

FC32: A5 87             LDA   mode            ; What are we doing between frames?
FC34: F0 10             BEQ   DoGameOvermode  ; 0 is "game over"
FC36: C9 01             CMP   #1              ; 1 is ...
FC38: F0 06             BEQ   DoPlaymode      ; ... "game play"
FC3A: 20 8C FD          JSR   SELMODE         ; 2 is "select game"
FC3D: 4C 49 FC          JMP   DrawFrame       ; Continue to the visible screen area
         ; JSR/RTS

DoPlaymode:
FC40: 20 38 FD          JSR   PLAYMODE        ; Playing-game processing
FC43: 4C 49 FC          JMP   DrawFrame       ; Continue to the visible screen area
         ; JSR/RTS

DoGameOvermode:
FC46: 20 A2 FD          JSR   GOMODE          ; Game-over processing (fall into DrawFrame)

DrawFrame:

         ;  ***** LENGTHY GAME LOGIC PROCESSING ENDS HERE *****

FC49: AD 84 02          LDA   INTIM           ; Wait for ...
FC4C: D0 FB          BNE   DrawFrame       ; ... of the screen

FC4E: 85 02          STA   WSYNC           ; 37th scanline
FC50: A9 00          LDA   #0              ; Turn the ...
FC52: 85 01          STA   VBLANK          ; ... beam back on

FC54: A9 00          LDA   #0              ; Zero out ...
FC56: 85 86          STA   scancnt         ; ... scanline count ...
FC58: 85 80          STA   tmp0            ; ... and all ...
FC5A: 85 81          STA   tmp1            ; ... returns ...
FC5C: 85 82          STA   tmp2            ; ... expected ...
FC5E: AA             TAX                   ; ... to come from BUILDROW

FC5F: 85 2C          STA   CXCLR           ; Clear collision detection

DrawVisibleRows:

         ;  BEGIN VISIBLE PART OF FRAME

FC61: A5 80             LDA   tmp0            ; Get A ready (PF0 value)
FC63: 85 02          STA   WSYNC           ; Wait for very start of row
FC65: 86 1B          STX   GRP0            ; Player 0 graphics (or blank) in X
FC67: 85 0D          STA   PF0             ; PF0 in tmp0 (already in A)
FC69: A5 81          LDA   tmp1            ; PF1 ...
FC6B: 85 0E          STA   PF1             ; ... in tmp1
FC6D: A5 82          LDA   tmp2            ; PP2 ...
FC6F: 85 0F          STA   PF2             ; ... in tmp2

FC71: 20 8D FC       JSR   BUILDROW        ; This MUST take through to the next line

FC74: E6 86          INC   scancnt         ; Next scan line
FC76: A5 86          LDA   scancnt         ; Do 109*2 = 218 lines
FC78: C9 6D          CMP   #109            ; All done?
FC7A: D0 E5          BNE   DrawVisibleRows ; No ... get all the visible rows

      ;  END VISIBLE PART OF FRAME

FC7C: A9 00          LDA   #0              ; Turn off electron beam
FC7E: 85 02          STA   WSYNC           ; Next scanline
FC80: 85 0D          STA   PF0             ; Play field 0 off
FC82: 85 1B          STA   GRP0            ; Player 0 off
FC84: 85 0E          STA   PF1             ; Play field 1 off
FC86: 85 0F          STA   PF2             ; Play field 2 off
FC88: 85 02          STA   WSYNC           ; Next scanline

FC8A: 4C 11 FC       JMP   VIDEO_KERNEL    ; Back to top of main loop

BUILDROW:

FC8D: A5 86          LDA   scancnt         ; Where are we on the screen?

FC8F: C9 06          CMP   #6              ; If we are in the ...
FC91: 90 39          BCC   SHOWSCORE       ; ... score area (nothing else up here)

FC93: 29 07          AND   #7              ; Lower 3 bits as an index
FC95: A8             TAY                   ; Using Y to lookup graphics
FC96: B9 8C FE       LDA   GR_PLAYER,Y     ; Get the graphics (if enabled on this row)
FC99: AA             TAX                   ; Hold it (for return as player 0)
FC9A: A5 86          LDA   scancnt         ; Scanline count again
FC9C: 4A             LSR   A               ; This time ...
FC9D: 4A             LSR   A               ; ... we divide ...
FC9E: 4A             LSR   A               ; ... by eight (8 rows in picture)

FC9F: C5 84          CMP   playr0y         ; Scanline group of the P0 object?
FCA1: F0 02          BEQ   ShowP0          ; Yes ... keep the picture
FCA3: A2 00          LDX   #0              ; Not time for Player 0 ... no graphics
ShowP0:
FCA5: A5 91             LDA   wallstart       ; Calculate ...
FCA7: 18             CLC                   ; ... the bottom ...
FCA8: 69 0A          ADC   #10             ; ... of ...
FCAA: 85 80          STA   tmp0            ; ... the wall

FCAC: A5 86          LDA   scancnt         ; Scanline count

FCAE: C5 91          CMP   wallstart       ; Past upper part of wall?
FCB0: 90 11          BCC   NoWall          ; No ... skip it
FCB2: C5 80          CMP   tmp0            ; Past lower part of wall
FCB4: B0 0D          BCS   NoWall          ; Yes ... skip it

      ;  The wall is on this row
FCB6: A5 8E          LDA   walldrela       ; Draw wall ...
FCB8: 85 80          STA   tmp0            ; ... by transfering ...
FCBA: A5 8F          LDA   walldrelb       ; ... playfield ...
FCBC: 85 81          STA   tmp1            ; ... patterns ...
FCBE: A5 90          LDA   walldrelc       ; ... to ...
FCC0: 85 82          STA   tmp2            ; ... return area
FCC2: 60             RTS

NoWall:
      ;  The wall is NOT on this row
FCC3: A9 00          LDA   #0              ; No walls on this row
FCC5: 85 80          STA   tmp0            ; ... clear ...
FCC7: 85 81          STA   tmp1            ; ... out ...
FCC9: 85 82          STA   tmp2            ; ... the playfield
FCCB: 60             RTS

SHOWSCORE:
FCCC: 29 07          AND   #7              ; Only need the lower 3 bits
FCCE: A8             TAY                   ; Soon to be an index into a list

      ;  At this point, the beam is past the loading of the
      ;  playfield for the left half. We want to make sure
      ;  that the right half of the playfield is off, so do that
      ;  now.

FCCF: A2 00          LDX   #0              ; Blank bit pattern
FCD1: 86 80          STX   tmp0            ; This will always be blank
FCD3: 86 0E          STX   PF1             ; Turn off playfield ...
FCD5: 86 0F          STX   PF2             ; ... for right half of the screen

FCD7: AA             TAX                   ; Another index
FCD8: B9 93 00       LDA   score_pf1,Y     ; Lookup the PF1 graphics for this row
FCDB: 85 81          STA   tmp1            ; Return it to the caller
FCDD: A8             TAY                   ; We'll need this value again in a second
FCDE: A9 00          LDA   #0              ; Blank digit
FCE0: 85 82          STA   tmp2            ; Return it to the caller

FCE2: 85 02          STA   WSYNC           ; Now on the next row

FCE4: 84 0E          STY   PF1             ; Repeat the left-side playfield ...
FCE6: 85 0F          STA   PF2             ; ... onto the new row

FCE8: A2 06          LDX   #6              ; Wait for ...
Delay1:
FCEA: CA       Delay1:  DEX                   ; ... left half of ...
FCEB: D0 FD          BNE   Delay1          ; ... playfield

      ;  The beam is past the left half of the field again.
      ;  Turn off the playfield.

FCED: 86 0E          STX   PF1             ; 0 to PF1 ...
FCEF: 86 0F          STX   PF2             ; ... and PF2
FCF1: 60             RTS

INIT:
         ;  This function is called ONCE at power-up/reset to initialize various
         ;  game settings and variables.

FCF2: A9 40             LDA   #64             ; Wall is ...
FCF4: 85 08             STA   COLUPF          ; ... redish
FCF6: A9 7E             LDA   #126            ; P0 is ...
FCF8: 85 06             STA   COLUP0          ; ... white

FCFA: A9 05             LDA   #5              ; Right half of playfield is reflection of left ...
FCFC: 85 0A             STA   CTRLPF          ; ... and playfield is on top of players

FCFE: A2 0A             LDX   #10             ; Player 0 position count
FD00: 85 02             STA   WSYNC           ; Get a fresh scanline

TimeP0Pos:
FD02: CA                DEX                   ; Kill time while the beam moves ...
FD03: D0 FD             BNE   TimeP0Pos       ; ... to position
FD05: 85 10             STA   RESP0           ; Mark player 0's X position
FD07: A9 0B             LDA   #11             ; near the bottom
FD09: 85 84             STA   playr0y         ; Player 0 Y coordinate

FD0B: A9 00             LDA   #0              ; Set score to ...
FD0D: 85 89             STA   wallcnt         ; ... 0
FD0F: 20 F2 FD          JSR   MAKE_SCORE      ; Blank the score digits
FD12: A9 00             LDA   #0              ; Blank bits ...
FD14: 85 98             STA   score_pf1+5     ; ... digit pattern

FD16: 20 3E FE          JSR   ADJUST_DIF      ; Initialize the wall parameters
FD19: 20 CB FD          JSR   NEW_GAPS        ; Build the wall's initial gap

FD1C: A9 70             LDA   #112            ; Set wall position off bottom ...
FD1E: 85 91             STA   wallstart       ; ... to force a restart on first move

FD20: A9 00             LDA   #0              ; Zero out ...
FD22: 85 20             STA   HMP0            ; ... player 0 motion

FD24: 60                RTS

INIT_PLAYMODE:

         ;  This function initializes the game play mode

FD25: A9 C0             LDA   #192            ; Background is ...
FD27: 85 09          STA   COLUBK          ; ... greenish
FD29: A9 01          LDA   #1              ; Game mode is ...
FD2B: 85 87          STA   mode            ; ... SELECT
FD2D: A9 FF          LDA   #255            ; Restart wall score to ...
FD2F: 85 89          STA   wallcnt         ; ... 0 on first move
FD31: A9 70          LDA   #112            ; Force wall to start ...
FD33: 85 91          STA   wallstart       ; ... over on first move
FD35: 4C 80 FE       JMP   INIT_MUSIC      ; Initialize the music and return
      ; JSR/RTS

PLAYMODE:

         ;  This function is called once per frame to process the main game play.

FD38: 20 6B FE          JSR   SEL_RESET_CHK   ; Check to see if Reset/Select has changed

FD3B: C9 00             CMP   #0              ; Is select pressed?
FD3D: F0 05             BEQ   NoSelect        ; No ... skip
FD3F: 86 8D             STX   debounce        ; Restore the old value ...
FD41: 4C 83 FD          JMP   INIT_SELMODE    ; ... and let select-mode process the toggle and return
         ; JSR/RTS

NoSelect:
FD44: 20 81 FE       JSR   PROCESS_MUSIC   ; Process any playing music
FD47: 20 AC FD       JSR   MOVE_WALLS      ; Move the walls

FD4A: C9 01          CMP   #1              ; Wall on first row?
FD4C: D0 0D          BNE   NoFirst         ; No ... move on
FD4E: E6 89          INC   wallcnt         ; Bump the score
FD50: 20 3E FE       JSR   ADJUST_DIF      ; Change the wall parameters based on score
FD53: A5 89          LDA   wallcnt         ; Change the ...
FD55: 20 F2 FD       JSR   MAKE_SCORE      ; ... score pattern
FD58: 20 CB FD       JSR   NEW_GAPS        ; Calculate the new gap position

NoFirst:
FD5B: A5 02          LDA   CXP0FB          ; Player 0 collision with playfield
FD5D: 29 80          AND   #128            ; Did player hit wall?
FD5F: F0 03          BEQ   NoHit           ; No ... move on
FD61: 4C 99 FD       JMP   INIT_GOMODE     ; Go to Game-Over mode

NoHit:
FD64: AD 80 02       LDA   SWCHA           ; Joystick
FD67: 29 80          AND   #128            ; Player 0 ... moving left
FD69: F0 11          BEQ   MoveP0Left      ; Yes ... move left
FD6B: AD 80 02       LDA   SWCHA           ; Joystick
FD6E: 29 40          AND   #64             ; Player 0 ... moving right?
FD70: F0 05          BEQ   MoveP0Right     ; Yes ... move right
FD72: A9 00          LDA   #0              ; Not moving value
FD74: 4C 80 FD       JMP   SetMoveP0       ; Don't move the player
MoveP0Right:
FD77: A9 10          LDA   #16             ; +1
FD79: 4C 80 FD       JMP   SetMoveP0       ; Set HMP0
MoveP0Left:
FD7C: E6 8C          INC   entropya
FD7E: A9 F0          LDA   #240            ; -1
SetMoveP0:
FD80: 85 20          STA   HMP0            ; New movement value P0
FD82: 60             RTS                   

INIT_SELMODE:
      ;
      ;  This function initializes the games SELECT-mode
      ;
FD83: A9 C8          LDA   #200            ; Background ...
FD85: 85 09          STA   COLUBK          ; ... greenish bright
FD87: A9 02          LDA   #2              ; Now in ...
FD89: 85 87          STA   mode            ; SELECT game mode
Out1:
FD8B: 60       Out1:    RTS   

SELMODE:
      ;
      ;  This function is called once per frame to process the SELECT-mode.
      ;  The wall moves here, but doesn't change or collide with players.
      ;  This function selects between 1 and 2 player game.
      ;
FD8C: 20 AC FD       JSR   MOVE_WALLS      ; Move the walls
FD8F: 20 6B FE       JSR   SEL_RESET_CHK   ; Check the reset/select switches
FD92: 29 01          AND   #1              ; RESET button?
FD94: F0 F5          BEQ   Out1            ; No ... skip
FD96: 4C 25 FD       JMP   INIT_PLAYMODE   ; Reset toggled ... start game
      ; JSR/RTS

INIT_GOMODE:

      ;  This function initializes the GAME-OVER game mode.

FD99: 85 2B          STA   HMCLR           ; Stop both players from moving
FD9B: A9 00          LDA   #0              ; Going to ...
FD9D: 85 87          STA   mode            ; ... game-over mode
FD9F: 4C 82 FE       JMP   INIT_GO_FX      ; Initialize sound effects
      ; JSR/RTS

GOMODE:

      ; This function is called every frame to process the game
      ; over sequence. When the sound effect has finished, the
      ; game switches to select mode.

FDA2: 20 87 FE       JSR   PROCESS_GO_FX   ; Process the sound effects
FDA5: C9 00          CMP   #0              ; Effects still running?
FDA7: D0 E2          BNE   Out1            ; Yes ... let them run
FDA9: 4C 83 FD       JMP   INIT_SELMODE    ; When effect is over, go to select mode
      ; JSR/RTS

MOVE_WALLS:

      ;  This function moves the wall down the screen and back to position 0
      ;  when it reaches (or passes) 112.

FDAC: C6 8A          DEC   walldely        ; Wall motion timer
FDAE: A5 8A          LDA   walldely        ; Time to ...
FDB0: D0 16          BNE   WallDone        ; No ... leave it alone
FDB2: A5 8B          LDA   walldelyr       ; Reset the ...
FDB4: 85 8A          STA   walldely        ; ... delay count
FDB6: A5 91          LDA   wallstart       ; Current wall position
FDB8: 18             CLC                   ; Increment ...
FDB9: 65 88          ADC   wall_inc        ; ... wall position
FDBB: C9 70          CMP   #112            ; At the bottom?
FDBD: 90 07          BCC   WallOK          ; No ... leave it alone
FDBF: A9 00          LDA   #0              ; Else restart ...
FDC1: 85 91          STA   wallstart       ; ... wall at top of screen
FDC3: A9 01          LDA   #1              ; Return flag that wall DID restart
FDC5: 60             RTS
WallOK:
FDC6: 85 91           STA   wallstart       ; Store new wall position
WallDone:
FDC8: A9 00          LDA   #0              ; Return flag that wall did NOT restart
FDCA: 60             RTS

NEW_GAPS:
      ;  This function builds the PF0, PF1, and PF2 graphics for a wall
      ;  with the gap pattern (gapbits) placed at random in the 20 bit
      ;  area.

FDCB: A9 FF          LDA   #255            ; Start with ...
FDCD: 85 8E          STA   walldrela       ; ... solid wall in PF0 ...
FDCF: 85 8F          STA   walldrelb       ; ... and PF1
FDD1: A5 92          LDA   gapbits         ; Store the gap pattern ...
FDD3: 85 90          STA   walldrelc       ; ... in PF2

FDD5: A5 8C             LDA   entropya        ; Get random
FDD7: 29 0F             AND   #15             ; 0 to 15
FDD9: C9 0C          CMP   #12             ; Too far to the right?
FDDB: F0 04          BEQ   GapOK           ; No ... 12 is OK
FDDD: 90 02          BCC   GapOK           ; No ... less than 12 is OK
FDDF: E9 09          SBC   #9              ; Back up 9

GapOK:
FDE1: C9 00          CMP   #0              ; Gap already at far left?
FDE3: F0 A6          BEQ   Out1            ; Yes ... done
FDE5: 38             SEC                   ; Roll gap ...
FDE6: 66 90          ROR   walldrelc       ; ... left ...
FDE8: 26 8F          ROL   walldrelb       ; ... desired ...
FDEA: 66 8E          ROR   walldrela       ; ... times ...
FDEC: 38             SEC                   ; All rolls ...
FDED: E9 01          SBC   #1              ; ... done?
FDEF: 4C E1 FD       JMP   GapOK           ; No ... do them all

MAKE_SCORE:

      ;  This function builds the PF1 and PF2 graphics rows for
      ;  the byte value passed in A. The current implementation is
      ;  two-digits only ... PF2 is blank.

FDF2: A2 00          LDX   #0              ; 100's digit
FDF4: A0 00          LDY   #0              ; 10's digit

Count100s:
FDF6: C9 64          CMP   #100            ; Need another 100s digit?
FDF8: 90 07          BCC   Count10s        ; No ... move on to 10s
FDFA: E8             INX                   ; Count ...
FDFB: 38             SEC                   ; ... value
FDFC: E9 64          SBC   #100            ; Take off this 100
FDFE: 4C F6 FD       JMP   Count100s       ; Keep counting
Count10s:
FE01: C9 0A          CMP   #10             ; Need another 10s digit?
FE03: 90 07          BCC   CountDone       ; No ... got all the tens
FE05: C8             INY                   ; Count ...
FE06: 38             SEC                   ; ... value
FE07: E9 0A          SBC   #10             ; Take off this 10
FE09: 4C 01 FE       JMP   Count10s        ; Keep counting

CountDone:
FE0C: 0A             ASL   A               ; One's digit ...
FE0D: 0A             ASL   A               ; ... *8 ....
FE0E: 0A             ASL   A               ; ... to find picture
FE0F: 85 81          STA   tmp1
FE11: 98             TYA                   ; Now the 10's digit
FE12: 0A             ASL   A               ; Multiply ...
FE13: 0A             ASL   A               ; ... by 8 ...
FE14: 0A             ASL   A               ; ... to find picture
FE15: 85 82          STA   tmp2            ; 10's picture in Y

      ; We have plenty of code space. Time and registers are at a premium.
      ; So copy/past the code for each row

FE17: A9 00          LDA   #0              ; Digit row ...
FE19: 85 83          STA   tmp3            ; ... counter

ScoreLoop:
FE1B: A6 82          LDX   tmp2            ; Left most digit
FE1D: BD 94 FE       LDA   DIGITS,X        ; Get the 10's digit pixels
FE20: 29 F0          AND   #0xF0           ; Upper nibble
FE22: 85 80          STA   tmp0            ; Store left side
FE24: A6 81          LDX   tmp1            ; Right most digit
FE26: BD 94 FE       LDA   DIGITS,X        ; Get the 1's digit pixels
FE29: 29 0F          AND   #0x0F           ; Lower nibble
FE2B: 05 80          ORA   tmp0            ; Put left and right half together
FE2D: A6 83          LDX   tmp3            ; Row counter
FE2F: 95 93          STA   score_pf1,X     ; Store calculated image for draw
FE31: E6 81          INC   tmp1            ; Next row in right digit
FE33: E6 82          INC   tmp2            ; Next row in left digit
FE35: E6 83          INC   tmp3            ; Next row count
FE37: A5 83          LDA   tmp3            ; Have we finished ...
FE39: C9 05          CMP   #5              ; ... all rows?
FE3B: D0 DE          BNE   ScoreLoop       ; No ... do them all

FE3D: 60             RTS

ADJUST_DIF:

      ;  This function adjusts the wall game difficulty values based on the
      ;  current score. The music can also change with the difficulty. A single
      ;  table describes the new values and when they take effect.

FE3E: A2 00          LDX   #0              ; Starting at index 0

AdjNextRow:
FE40: BD 99 FE       LDA   SKILL_VALUES,X  ; Get the score match
FE43: C9 FF          CMP   #255            ; At the end of the table?
FE45: F0 1B          BEQ   Out2            ; Yes ... leave it alone

FE47: C5 89          CMP   wallcnt         ; Is this our entry?
FE49: D0 18          BNE   AdjBump         ; No ... bump to next

FE4B: A0 01          LDY   #1              ; Increment by 1 ...
FE4D: C9 40          CMP   #64             ; ... until 64 rows ...
FE4F: 90 01          BCC   StillLow        ; ... then ...
FE51: C8             INY                   ; ... by 2
StillLow:
FE52: 84 88          STY   wall_inc        ; New increment

FE54: E8             INX                   ; Copy ...
FE55: BD 99 FE       LDA   SKILL_VALUES,X  ; ... new ...
FE58: 85 8A          STA   walldely        ; ... wall delay
FE5A: 85 8B          STA   walldelyr

FE5C: E8             INX                   ; Copy ...
FE5D: BD 99 FE       LDA   SKILL_VALUES,X  ; ... new ...
FE60: 85 92          STA   gapbits         ; ... gap pattern
Out2:
FE62: 60       Out2:    RTS

AdjBump:
FE63: 8A       AdjBump: TXA                   ; Move ...
FE64: 18             CLC                   ; ... X to ...
FE65: 69 08          ADC   #8              ; ... next ...
FE67: AA             TAX                   ; ... entry

FE68: 4C 40 FE       JMP    AdjNextRow      ; Try next row


SEL_RESET_CHK:

      ;  This function checks for changes to the reset/select
      ;  switches and debounces the transitions.
      ;  xxxxxxSR (Select, Reset)

FE6B: A6 8D          LDX   debounce        ; Get the last value
FE6D: AD 82 02       LDA   SWCHB           ; New value
FE70: 29 03          AND   #3              ; Only need bottom 2 bits
FE72: C5 8D          CMP   debounce        ; Same as before?
FE74: F0 07          BEQ   SelDebounce     ; Yes ... return nothing changed
FE76: 85 8D          STA   debounce        ; Hold new last value
FE78: 49 FF          EOR   #255            ; Active low to active high
FE7A: 29 03          AND   #3              ; Only need select/reset
FE7C: 60             RTS                   ; Return changes
SelDebounce:
FE7D: A9 00          LDA   #0              ; Return 0 ...
FE7F: 60             RTS                   ; ... nothing changed

INIT_MUSIC:
FE80: 60                RTS

PROCESS_MUSIC:
FE81: 60                RTS

INIT_GO_FX:
FE82: A9 64          LDA   #100
FE84: 85 85          STA   mustmp1
FE86: 60             RTS

PROCESS_GO_FX:
FE87: C6 85          DEC   mustmp1
FE89: A5 85          LDA   mustmp1
FE8B: 60             RTS

GR_PLAYER:
      ;  Image for players (8x8)
      .subs .=0, *=1
      ;
FE8C: 10             .byte    0b__...*....
FE8D: 10             .byte    0b__...*....
FE8E: 28             .byte    0b__..*.*...
FE8F: 28             .byte    0b__..*.*...
FE90: 54             .byte    0b__.*.*.*..
FE91: 54             .byte    0b__.*.*.*..
FE92: AA             .byte    0b__*.*.*.*.
FE93: 7C             .byte    0b__.*****..

DIGITS:
      ;  Images for numbers:
      ;  We only need 5 rows, but the extra space on the end makes each digit 8 rows,
      ;  which makes it the multiplication easier.

      ;  The skill-adjustment table is woven into the digits. Each
      ;  digit has 3 bytes wasted for easy lookup-math. The rows
      ;  of the adjustment table fit nicely.
      ;
      ;  This table describes how to change the various
      ;  difficulty parameters as the game progresses.
      ;  For instance, the second entry in the table
      ;  says that when the score is 4, change the values of
      ;  wall-increment to 1, frame-delay to 2, and gap-pattern
      ;  to 0. A 255 on the end of the table indicates the end.
      ;
      ;  For example:
      ;        Wall     Delay    Gap
      ; .byte    5,        3,     7

FE94: 0E             .byte   0b__....***.  ; 0 (leading 0 is blank)
FE95: 0A             .byte   0b__....*.*.
FE96: 0A             .byte   0b__....*.*.
FE97: 0A             .byte   0b__....*.*.
FE98: 0E             .byte   0b__....***.
SKILL_VALUES:
FE99: 00 03 00       .byte    0, 3, 0

FE9C: 22             .byte   0b__..*...*.  ; 1
FE9D: 22             .byte   0b__..*...*.
FE9E: 22             .byte   0b__..*...*.
FE9F: 22             .byte   0b__..*...*.
FEA0: 22             .byte   0b__..*...*.
      ;
FEA1: 04 02 00       .byte   4, 2, 0

FEA4: EE             .byte   0b__***.***.  ; 2
FEA5: 22             .byte   0b__..*...*.
FEA6: EE             .byte   0b__***.***.
FEA7: 88             .byte   0b__*...*...
FEA8: EE             .byte   0b__***.***.
      ;
FEA9: 0C 02 01       .byte   12, 2, 1

FEAC: EE             .byte   0b__***.***.  ; 3
FEAD: 22             .byte   0b__..*...*.
FEAE: 66             .byte   0b__.**..**.
FEAF: 22             .byte   0b__..*...*.
FEB0: EE             .byte   0b__***.***.
      ;
FEB1: 18 01 03       .byte   24, 1, 3

FEB4: AA             .byte   0b__*.*.*.*.  ; 4
FEB5: AA             .byte   0b__*.*.*.*.
FEB6: EE             .byte   0b__***.***.
FEB7: 22             .byte   0b__..*...*.
FEB8: 22             .byte   0b__..*...*.
      ;
FEB9: 20 01 07       .byte   32, 1, 7

FEBC: EE             .byte   0b__***.***. ; 5
FEBD: 88             .byte   0b__*...*...
FEBE: EE             .byte   0b__***.***.
FEBF: 22             .byte   0b__..*...*.
FEC0: EE             .byte   0b__***.***.
      ;
FEC1: 28 01 0F       .byte   40, 1, 15

FEC4: EE             .byte   0b__***.***. ; 6
FEC5: 88             .byte   0b__*...*...
FEC6: EE             .byte   0b__***.***.
FEC7: AA             .byte   0b__*.*.*.*.
FEC8: EE             .byte   0b__***.***.
      ;
FEC9: 40 01 01       .byte   64, 1, 1

FECC: EE             .byte   0b__***.***. ; 7
FECD: 22             .byte   0b__..*...*.
FECE: 22             .byte   0b__..*...*.
FECF: 22             .byte   0b__..*...*.
FED0: 22             .byte   0b__..*...*.
      ;
FED1: 50 01 03       .byte   80, 1, 3

FED4: EE             .byte   0b__***.***. ; 8
FED5: AA             .byte   0b__*.*.*.*.
FED6: EE             .byte   0b__***.***.
FED7: AA             .byte   0b__*.*.*.*.
FED8: EE             .byte   0b__***.***.
      ;
FED9: 60 01 07       .byte   96, 1, 7

FEDC: EE             .byte   0b__***.***. ; 9
FEDD: AA             .byte   0b__*.*.*.*.
FEDE: EE             .byte   0b__***.***.
FEDF: 22             .byte   0b__..*...*.
FEE0: EE             .byte   0b__***.***.
      ;
LAST:
FEE1: FF       LAST:    .byte   255


; 6502 vectors
FFFA: 00 FC    FFFA:    .word MAIN
FFFC: 00 FC          .word MAIN  ; Reset vector (top of program)
FFFE: 00 FC          .word MAIN
